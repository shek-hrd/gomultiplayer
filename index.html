<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>GOMultiplayer – Click Race (P2P)</title>
  <style>
    body{margin:0;font-family:sans-serif;background:#111;color:#eee}
    #ui{position:fixed;top:0;left:0;right:0;background:#222;padding:8px;text-align:center}
    #gameCanvas{background:#000;display:block;margin:60px auto;border:1px solid #444}
    button{margin:0 6px;padding:6px 12px}
  </style>
</head>
<body>

<div id="ui">
  <span id="status">Connecting to signaller…</span>
  <button id="hostBtn" hidden>Host Game</button>
  <button id="joinBtn" hidden>Join Game</button>
  <span id="codeDisplay"></span>
</div>

<canvas id="gameCanvas" width="600" height="400"></canvas>

<script>
/* ------------------------------------------------------------------
 * 1)  Signalling layer (Socket.IO client ➜ wss://network-dating-signaler.onrender.com)
 * ------------------------------------------------------------------ */
const SIGNAL_URL = 'wss://network-dating-signaler.onrender.com';
const socket = io(SIGNAL_URL, { transports: ['websocket'] });

let myId      = null;   // our socket id
let peerId    = null;   // the other guy
let rtcConn   = null;   // RTCPeerConnection
let dataChan  = null;   // RTCDataChannel

socket.on('connect', () => {
  myId = socket.id;
  status.textContent = 'Connected to signaller';
  hostBtn.hidden = joinBtn.hidden = false;
});

socket.on('users-present', ids => {
  // if somebody is already here, enable Join button
  if (ids.length) joinBtn.hidden = false;
});

socket.on('user-joined', id => {
  // somebody just arrived, let me join him
  if (!rtcConn) joinBtn.hidden = false;
});

socket.on('user-left', id => {
  if (id === peerId) resetGame('Peer left');
});

socket.on('signal', async ({ from, signal }) => {
  peerId = from;
  if (signal.type === 'offer')  await handleOffer(signal);
  if (signal.type === 'answer') await handleAnswer(signal);
  if (signal.candidate)         rtcConn.addIceCandidate(signal);
});

/* ------------------------------------------------------------------
 * 2)  WebRTC boiler-plate
 * ------------------------------------------------------------------ */
const ICE = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

function createPeer(isInitiator) {
  rtcConn = new RTCPeerConnection(ICE);

  rtcConn.onicecandidate = e => {
    if (e.candidate) socket.emit('signal', { to: peerId, from: myId, signal: e.candidate });
  };

  rtcConn.onconnectionstatechange = () => {
    if (rtcConn.connectionState === 'connected') status.textContent = 'P2P connected!';
    if (rtcConn.connectionState === 'disconnected') resetGame('Peer disconnected');
  };

  if (isInitiator) {
    dataChan = rtcConn.createDataChannel('game');
    setupDataChannel(dataChan);
    rtcConn.createOffer()
      .then(o => rtcConn.setLocalDescription(o))
      .then(() => socket.emit('signal', { to: peerId, from: myId, signal: rtcConn.localDescription }));
  } else {
    rtcConn.ondatachannel = e => {
      dataChan = e.channel;
      setupDataChannel(dataChan);
    };
  }
}

function setupDataChannel(chan) {
  chan.onopen    = () => status.textContent = 'P2P data channel open';
  chan.onmessage = e => handleRemoteMessage(JSON.parse(e.data));
  chan.onclose   = ()  => resetGame('Data channel closed');
}

function send(msg) {
  if (dataChan && dataChan.readyState === 'open') dataChan.send(JSON.stringify(msg));
}

async function handleOffer(offer) {
  createPeer(false);
  await rtcConn.setRemoteDescription(offer);
  const answer = await rtcConn.createAnswer();
  await rtcConn.setLocalDescription(answer);
  socket.emit('signal', { to: peerId, from: myId, signal: answer });
}

async function handleAnswer(answer) {
  await rtcConn.setRemoteDescription(answer);
}

/* ------------------------------------------------------------------
 * 3)  Game state & UI
 * ------------------------------------------------------------------ */
const canvas = document.getElementById('gameCanvas');
const ctx     = canvas.getContext('2d');
const status  = document.getElementById('status');
const hostBtn = document.getElementById('hostBtn');
const joinBtn = document.getElementById('joinBtn');
const codeDisplay = document.getElementById('codeDisplay');

let players = {};   // id -> {x, y, score}
let winner  = null;

hostBtn.onclick = () => {
  socket.emit('users-present', []); // trigger users-present
  const ids = [...document.querySelectorAll('#ui span')].map(s => s.id); // dummy
  const partner = prompt('Ask the other player to paste your ID below:\n' + myId);
  if (partner) {
    peerId = partner;
    createPeer(true);
    hostBtn.hidden = joinBtn.hidden = true;
    codeDisplay.textContent = 'Hosting ' + myId;
  }
};

joinBtn.onclick = () => {
  const code = prompt('Enter host ID:');
  if (code) {
    peerId = code;
    createPeer(false);
    hostBtn.hidden = joinBtn.hidden = true;
    codeDisplay.textContent = 'Joining ' + peerId;
  }
};

/* ------------------------------------------------------------------
 * 4)  Game logic
 * ------------------------------------------------------------------ */
function resetGame(msg) {
  status.textContent = msg || 'Reset';
  players = {};
  winner  = null;
  rtcConn = null;
  dataChan = null;
  hostBtn.hidden = joinBtn.hidden = false;
  codeDisplay.textContent = '';
}

function updateGame(msg) {
  if (msg.players) players = msg.players;
  if (msg.winner)  winner = msg.winner;
  draw();
}

function handleRemoteMessage(msg) {
  if (msg.type === 'state') updateGame(msg);
}

function broadcastState() {
  send({ type: 'state', players, winner });
}

canvas.addEventListener('click', () => {
  if (winner) return;
  if (!players[myId]) players[myId] = { x: 50, y: 50, score: 0 };
  players[myId].score += 1;
  if (players[myId].score >= 10) winner = myId;
  broadcastState();
});

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (const [id, p] of Object.entries(players)) {
    ctx.fillStyle = id === myId ? '#0f0' : '#f00';
    ctx.beginPath();
    ctx.arc(p.x + 15, p.y + 15, 15, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillText(p.score, p.x, p.y - 5);
  }
  if (winner) {
    ctx.fillStyle = '#fff';
    ctx.font = '32px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`Winner: ${winner === myId ? 'You' : 'Peer'}!`, 300, 200);
  }
}

setInterval(draw, 1000 / 60); // 60 fps render

/* ------------------------------------------------------------------
 * 5)  Load Socket.IO client
 * ------------------------------------------------------------------ */
const s = document.createElement('script');
s.src = 'https://cdn.socket.io/4.7.2/socket.io.min.js';
document.head.appendChild(s);
</script>
</body>
</html>